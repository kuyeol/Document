# Logic Gates

- 제공된 C 코드를 기반으로 이진수와 그레이 코드(Gray code) 간의 변환 알고리즘을 설명하고, 요청하신 "4비트 동시 변형(Four-bit-at-once variant)"을 자바 코드로 구현해 드리겠습니다.

### 그레이 코드(Gray Code) 변환

그레이 코드는 연속된 두 수가 단 하나의 비트만 다른 속성을 가지는 이진 숫자 체계입니다. 이러한 특성 때문에 하드웨어 등에서 오류를 줄이는 데 유용하게 사용됩니다.

제공된 C 코드는 부호 없는 이진수(unsigned binary)를 반사 이진 그레이 코드(reflected binary Gray code)로 변환하거나 그 반대로 변환하는 함수들을 포함하고 있습니다. 이 알고리즘들은 업로드된 문서인 **Hacker's Delight, Second Edition**의 13장 "GRAY CODE"에서 설명하는 기법들입니다.

아래는 제공된 C 함수들을 자바(Java)로 변환한 코드입니다. 자바에는 C의 `unsigned int`와 정확히 일치하는 타입이 없지만, 32비트 정수 `int`를 사용하고 논리적 오른쪽 시프트 연산자인 `>>>`를 사용하여 동일한 결과를 얻을 수 있습니다.

```java
public class GrayCodeConverter {

    /**
     * 이 함수는 부호 없는 이진수를 반사 이진 그레이 코드로 변환합니다.
     * @param num 부호 없는 이진수 정수
     * @return 변환된 그레이 코드
     */
    public static int binaryToGray(int num) {
        // num을 오른쪽으로 1비트 시프트한 값과 XOR 연산을 합니다.
        return num ^ (num >>> 1);
    }

    /**
     * 이 함수는 반사 이진 그레이 코드를 이진수로 변환합니다.
     * @param num 그레이 코드 정수
     * @return 변환된 이진수
     */
    public static int grayToBinary(int num) {
        int mask = num;
        while (mask != 0) {
            mask >>>= 1;
            num ^= mask;
        }
        return num;
    }

    /**
     * 32비트 이하 그레이 코드를 위한 더 효율적인 변환 함수입니다. (SWAR 기법)
     * 병렬 접두사 XOR(parallel prefix XOR) 함수를 구현합니다.
     * @param num 32비트 그레이 코드 정수
     * @return 변환된 이진수
     */
    public static int grayToBinary32(int num) {
        num ^= num >>> 16;
        num ^= num >>> 8;
        num ^= num >>> 4;
        num ^= num >>> 2;
        num ^= num >>> 1;
        return num;
    }
}
```

### 4비트 동시 변형 (Four-bit-at-once variant) 자바 코드

요청하신 "A Four-bit-at-once variant changes a binary number (abcd)2 to (abcd)2 ^ (00ab)2, then to (abcd)2 ^ (00ab)2 ^ (0abc)2 ^ (000a)2"라는 설명은 4비트 그레이 코드를 이진수로 변환하는 공식을 나타내는 것으로 보입니다. 이 설명은 `GrayToBinary` 함수의 원리를 4비트에 대해 풀어 쓴 것입니다.

4비트 그레이 코드 `g = g₃g₂g₁g₀`를 이진수 `b = b₃b₂b₁b₀`로 변환하는 공식은 다음과 같습니다.

*   `b₃ = g₃`
*   `b₂ = g₃ ⊕ g₂`
*   `b₁ = g₃ ⊕ g₂ ⊕ g₁`
*   `b₀ = g₃ ⊕ g₂ ⊕ g₁ ⊕ g₀`

이것은 `b = g ⊕ (g >> 1) ⊕ (g >> 2) ⊕ (g >> 3)` 와 동일합니다.

요청하신 설명에서 `(abcd)₂`를 그레이 코드 `g`라고 할 때, 각 부분은 다음과 같이 해석할 수 있습니다.

*   `(abcd)₂`  => `g`
*   `(00ab)₂`  => `g >>> 2`
*   `(0abc)₂`  => `g >>> 1`
*   `(000a)₂`  => `g >>> 3`

따라서 설명된 표현은 `g ^ (g >>> 2) ^ (g >>> 1) ^ (g >>> 3)`이 되며, 이는 XOR 연산의 순서만 바뀐 것일 뿐 위에서 설명한 4비트 변환 공식과 동일합니다.

이 원리를 구현한 자바 코드는 다음과 같습니다.

```java
public class GrayCodeConverter {

    // ... 위에서 정의한 다른 메소드들 ...

    /**
     * 4비트 그레이 코드를 이진수로 변환하는 "Four-bit-at-once" 변형입니다.
     * 이 함수는 일반적인 grayToBinary 함수의 4비트 특화 버전입니다.
     * @param gray4bit 4비트 그레이 코드 (상위 비트는 무시됨)
     * @return 변환된 4비트 이진수
     */
    public static int grayToBinary4(int gray4bit) {
        // 입력이 4비트를 넘지 않도록 마스크 처리
        int g = gray4bit & 0xF; 
        
        // g = abcd, g >>> 1 = 0abc, g >>> 2 = 00ab, g >>> 3 = 000a
        // 요청된 설명에 따른 계산: g ^ (g >>> 2) ^ (g >>> 1) ^ (g >>> 3)
        // 이는 g ^ (g >>> 1) ^ (g >>> 2) ^ (g >>> 3) 와 동일합니다.
        return g ^ (g >>> 1) ^ (g >>> 2) ^ (g >>> 3);
    }

    /**
     * 4비트 그레이 코드를 이진수로 변환하는 SWAR 방식의 변형입니다.
     * grayToBinary32 함수의 4비트 특화 버전입니다.
     * @param gray4bit 4비트 그레이 코드 (상위 비트는 무시됨)
     * @return 변환된 4비트 이진수
     */
    public static int grayToBinary4Swar(int gray4bit) {
        int num = gray4bit & 0xF; // 입력이 4비트를 넘지 않도록 마스크 처리
        num ^= num >>> 2;
        num ^= num >>> 1;
        return num;
    }

    public static void main(String[] args) {
        // 예제: 10진수 10 (이진수 1010)
        int binary = 10; 
        
        // 이진수 -> 그레이 코드
        int gray = binaryToGray(binary);
        System.out.println("Binary " + Integer.toBinaryString(binary) + " -> Gray " + Integer.toBinaryString(gray));

        // 그레이 코드 -> 이진수
        int convertedBinary = grayToBinary(gray);
        System.out.println("Gray " + Integer.toBinaryString(gray) + " -> Binary " + Integer.toBinaryString(convertedBinary));

        // 32비트 SWAR 방식
        int convertedBinary32 = grayToBinary32(gray);
        System.out.println("Gray " + Integer.toBinaryString(gray) + " -> Binary (32-bit SWAR) " + Integer.toBinaryString(convertedBinary32));
        
        // 4비트 변형 방식 테스트
        // 예: 그레이 코드 1101 (10진수 13) -> 이진수 1001 (10진수 9)
        int gray4 = 13; // 1101
        int binary4 = grayToBinary4(gray4);
        System.out.println("\n4-bit variant test:");
        System.out.println("Gray " + Integer.toBinaryString(gray4) + " -> Binary " + Integer.toBinaryString(binary4));

        int binary4Swar = grayToBinary4Swar(gray4);
        System.out.println("Gray " + Integer.toBinaryString(gray4) + " -> Binary (4-bit SWAR) " + Integer.toBinaryString(binary4Swar));
    }
}
```

---

**[USER]** (2025. 11. 2. 오후 9:29:00)

상태 표현에 사용될수 있나?

---

**[MODEL]** (2025. 11. 2. 오후 9:29:00)

네, 제공된 자료에 따르면 비트, 숫자 체계, 그리고 다양한 알고리즘은 상태(state)를 표현하는 데 사용될 수 있으며, 실제로 널리 사용됩니다.

### 기본 원리: 이진법과 상태

컴퓨터는 근본적으로 이진법을 사용하여 정보를 표현합니다. 이진법의 두 숫자 0과 1은 두 가지 명확히 구분되는 상태를 나타내는 데 이상적입니다. 예를 들어, 이는 회로에서 스위치가 켜진(on) 상태와 꺼진(off) 상태, 또는 전하가 있고 없음 등으로 표현될 수 있습니다. [^1]

### 구체적인 예시 및 기법

**1. 그레이 코드 (Gray Code)**

그레이 코드는 연속된 값이 단 하나의 비트만 변경되도록 설계된 인코딩 방식입니다. 이 특성은 물리적인 위치나 상태를 표현하는 시스템에서 매우 유용합니다. 예를 들어, 회전 위치 센서에서 여러 비트가 동시에 변경될 때 발생할 수 있는 오독(misreading)의 위험을 줄여줍니다. 한 상태에서 다음 상태로 전환될 때 단 하나의 비트만 바뀌므로, 전환 과정에서 발생할 수 있는 모호함이 크게 감소합니다.[^2]

**2. 3치 비교 함수 (Three-Valued Compare Function)**

책 "Hacker's Delight"에서는 두 값을 비교하여 세 가지 상태 중 하나를 반환하는 함수를 설명합니다. 이 함수는 결과로 -1, 0, 또는 1을 반환하며, 이는 각각 "작음(less than)", "같음(equal to)", "큼(greater than)"의 세 가지 상태를 나타냅니다.[^3]

**3. 비트 조작을 통한 상태 관리**

"Hacker's Delight"에서 다루는 수많은 비트 조작 기술들은 근본적으로 컴퓨터 내의 상태를 효율적으로 표현하고 변경하는 방법에 관한 것입니다. 예를 들어, 특정 비트를 켜거나 끄는 것은 특정 플래그(flag)나 옵션의 상태를 설정하거나 해제하는 데 사용될 수 있습니다.

다음은 특정 상태를 표현하고 조작하는 데 사용되는 몇 가지 공식입니다.[^4]
*   **가장 오른쪽 1-비트 끄기**: `x & (x - 1)`
    *   이 공식은 어떤 집합에서 한 요소를 제거하는 등의 상태 변화를 나타낼 수 있습니다.
*   **가장 오른쪽 1-비트 분리하기**: `x & (-x)`
    *   가장 낮은 우선순위의 작업을 식별하는 데 사용될 수 있습니다.

이러한 기법들은 모두 컴퓨터 워드 내의 비트 패턴을 변경하여 상태를 표현하고 전환하는 데 사용됩니다.

**4. 특이한 진법을 이용한 상태 표현**

-2진법(Base -2)과 같은 특이한 숫자 체계는 별도의 부호 비트 없이 양수와 음수를 모두 표현할 수 있습니다. 이는 숫자의 부호 상태를 표현하는 또 다른 방법을 보여줍니다.[^5]

결론적으로, 제공된 두 문서는 컴퓨터 과학의 기본인 이진 표현부터 고급 알고리즘에 이르기까지 다양한 수준에서 '상태 표현'이 어떻게 이루어지는지를 잘 보여줍니다.

[^1]: Advanced Binary for Programming & Computer Science.pdf, p. 19
[^2]: hacker_s_delight_2nd_edition.pdf, pp. 282, 285–286, Sections "13–1 Gray Code", "13–4 Brief History and Applications"
[^3]: hacker_s_delight_2nd_edition.pdf, p. 32, Section "2–9 Three-Valued Compare Function"
[^4]: hacker_s_delight_2nd_edition.pdf, p. 24, Section "2–1 Manipulating Rightmost Bits"
[^5]: hacker_s_delight_2nd_edition.pdf, p. 271, Section "12–1 Base –2"

---

**[USER]** (2025. 11. 2. 오후 9:31:53)

4가지 상태가 필요한경우 사용 설명

---

**[MODEL]** (2025. 11. 2. 오후 9:31:53)

제공된 문서들은 4가지 상태가 필요한 경우를 불리언 논리(Boolean logic) 및 컴퓨터 하드웨어 설계의 맥락에서 설명합니다. 주요 사례는 2개의 이진 입력(binary input)으로 인해 발생하는 4가지 조합을 처리하는 경우입니다.

### 1. 2입력 부울 논리 게이트 (Two-Input Boolean Logic Gates)

가장 기본적인 예시는 AND, OR, XOR과 같은 2개의 입력을 받는 논리 연산에서 찾아볼 수 있습니다. 각 입력은 0(false) 또는 1(true)의 값을 가질 수 있으므로, 총 4가지의 입력 상태 조합이 발생합니다. 논리 게이트의 동작은 이 4가지 상태 각각에 대한 출력을 정의하는 진리표(truth table)로 설명됩니다 (업로드된 문서 `Advanced Binary for Programming & Computer Science: Logical, Bitwise and Arithmetic Operations, and Data Encoding and Representation`, pages 42-43).

4가지 입력 상태는 다음과 같습니다:
*   `0` 과 `0`
*   `0` 과 `1`
*   `1` 과 `0`
*   `1` 과 `1`

예를 들어, **AND 연산**의 진리표는 두 입력이 모두 `1`인 경우에만 출력이 `1`이 되며, 나머지 3가지 상태에서는 출력이 `0`이 됩니다 (업로드된 문서 `Advanced Binary for Programming & Computer Science: Logical, Bitwise and Arithmetic Operations, and Data Encoding and Representation`, page 42).

### 2. 16가지 모든 이진 부울 연산 구현

컴퓨터 하드웨어에서 두 변수 `x`와 `y`에 대한 16가지 모든 이진 부울 연산을 구현하는 회로를 설계할 때 4가지 상태를 활용할 수 있습니다. 이 회로는 2개의 입력 비트 `x`와 `y`가 가질 수 있는 4가지 상태(00, 01, 10, 11)에 따라 출력을 선택합니다.

이러한 회로는 **4:1 MUX(멀티플렉서)**를 사용하여 구현할 수 있으며, 이는 "4위치 회전 스위치(four-position rotary switch)"처럼 작동합니다. 입력 `x`와 `y`의 4가지 상태에 따라, MUX는 4개의 연산 코드 비트(`c0`, `c1`, `c2`, `c3`) 중 하나를 출력으로 선택하여 16가지 연산 중 원하는 결과를 생성합니다 (업로드된 문서 `Hacker’s Delight, Second Edition`, page 60).

---

**[SYSTEM]** (2025. 11. 2. 오후 9:37:15)

Starting translation for pages 55-61...

---

**[MODEL]** (2025. 11. 2. 오후 9:37:15)

**Page 55 Translation:**

**다이어그램 설명:**

페이지 상단에는 변수 `x`를 나타내는 다이어그램이 있습니다. 이 변수는 5개의 필드(A, B, C, D, E)로 나뉘어 있습니다. 필드 C의 시작부터 필드 D의 끝까지 `k`라는 레이블이 붙은 양방향 화살표가 있어, 이 두 필드에 걸친 거리를 나타냅니다.

```
x: [ A | B | C | D | E ]
           <---- k ---->
```

---

직관적인 코드는 D와 B를 새 위치로 시프트하고, `and` 및 `or` 연산을 사용하여 단어들을 결합하는 방식이며, 다음과 같습니다:

t₁ = (x & m) << k
t₂ = (x >> k) & m
x' = (x & m') | t₁ | t₂

여기서, **m**은 필드 D에 1을 가지고 (다른 곳은 0인) 마스크이며, **m'**은 필드 A, C, E에 1을 가진 마스크입니다. 이 코드는 두 마스크를 생성하는 데 4개의 명령어가 필요하다고 가정할 때, 무제한 명령어 수준 병렬성을 가진 기계에서 11개의 명령어와 6개의 사이클을 필요로 합니다.

동일한 가정 하에, 8개의 명령어만 필요하고 5개의 사이클 내에 실행되는 방법이 아래에 나와 있습니다 [GLS1]. 이는 두 레지스터의 해당 필드를 교환하기 위한 46페이지의 (c)열에 있는 코드와 유사합니다. 여기서도 **m**은 필드 D를 분리하는 마스크입니다.

t₁ = [x ⊕ (x >> k)] & m
t₂ = t₁ << k
x' = x ⊕ t₁ ⊕ t₂

이 아이디어는 t₁이 D 위치에 B ⊕ D를 포함하고 (다른 곳은 0), t₂는 B 위치에 B ⊕ D를 포함한다는 것입니다. 이 코드와 앞에서 제시된 직관적인 코드는 B와 D가 "분할 필드(split fields)"일 경우, 즉 마스크 **m**의 1-비트들이 연속적이지 않을 경우에 올바르게 작동합니다.

### 조건부 교환 (Conditional Exchange)

배타적 논리합(exclusive or)에 기반한 이전 두 섹션의 교환 방법들은 마스크 **m**이 0이면 아무 연산도 하지 않는(no-operations) 것으로 축소됩니다. 따라서, 어떤 조건 **c**가 **참(true)**일 때 **m**을 모두 1로 설정하고, **c**가 **거짓(false)**일 때 모두 0으로 설정하면, 전체 레지스터, 두 레지스터의 해당 필드, 또는 동일한 레지스터의 두 필드를 교환하는 연산을 수행할 수 있습니다. 이는 분기 없이 **m**을 설정할 수 있다면 분기 없는(branch-free) 코드를 가능하게 합니다.

### 2-21 두 개 이상의 값 사이에서 번갈아 바꾸기 (Alternating among Two or More Values)

변수 x가 a와 b라는 두 가지 가능한 값만 가질 수 있고, x에 현재 값이 아닌 다른 값을 할당하고자 하며, 코드가 a와 b의 실제 값에 의존하지 않기를 원한다고 가정해 봅시다. 예를 들어, 컴파일러에서 x는 `branch true` 또는 `branch false` 중 하나로 알려진 연산 부호(opcode)일 수 있으며, 어느 쪽이든 다른 쪽으로 전환하고 싶을 수 있습니다. `branch true`와 `branch false` 연산 부호의 값은 임의적이며, 아마도 헤더 파일에서 C의 `#define`이나 `enum` 선언으로 정의되었을 것입니다.

이 전환을 수행하는 직관적인 코드는 다음과 같습니다.

```c
if (x == a) x = b;
else x = a;
```

또는, C 프로그램에서 자주 볼 수 있듯이,

---

**[MODEL]** (2025. 11. 2. 오후 9:37:47)

**Page 56 Translation:**

[코드 이미지를 보려면 여기를 클릭하세요](https://i.stack.imgur.com/1Zp5I.png)

```c
x = x == a ? b : a;
```

이를 코딩하는 훨씬 더 나은 (또는 적어도 더 효율적인) 방법은 다음과 같습니다.

`x ← a + b − x, 또는`
`x ← a ⊕ b ⊕ x.`

만약 `a`와 `b`가 상수라면, 이는 한두 개의 기본적인 RISC 명령어만 필요합니다. 물론, `a + b`를 계산할 때 발생하는 오버플로는 무시할 수 있습니다.

이는 다음과 같은 질문을 제기합니다: 세 개 이상의 값 사이를 순환하는 특별히 효율적인 방법이 있을까요? 즉, 임의의 서로 다른 세 상수 `a`, `b`, `c`가 주어졌을 때, 다음을 만족하는 평가하기 쉬운 함수 `f`를 찾고자 합니다.

`f(a) = b,`
`f(b) = c, 이고`
`f(c) = a.`

아마도 이러한 함수에 대해 항상 다항식이 존재한다는 점은 흥미로울 것입니다. 세 개의 상수의 경우,

`f(x) = (x − a)(x – b) / ((c − a)(c − b)) * a + (x – b)(x − c) / ((a − b)(a − c)) * b + (x − c)(x − a) / ((b − c)(b − a)) * c. (5)`

(아이디어는 `x = a`이면 첫 번째와 마지막 항은 사라지고, 중간 항은 `b`로 단순화되는 식입니다.) 이를 평가하려면 14개의 산술 연산이 필요하며, 임의의 `a`, `b`, `c`에 대해 중간 결과가 컴퓨터의 워드 크기를 초과할 수 있습니다. 하지만 이것은 단지 2차식입니다. 만약 다항식의 일반적인 형태로 작성하고 호너의 방법(Horner's rule)⁵을 사용하여 평가한다면, 단 5개의 산술 연산(정수 계수를 가진 2차식에 4개, 마지막 나눗셈에 1개)만 필요할 것입니다. 따라서 방정식 (5)를 재정리하면 다음과 같습니다.

`f(x) = 1 / ((a − b)(a − c)(b − c)) * {[(a − b)a + (b − c)b + (c − a)c]x² + [(a − b)b² + (b − c)c² + (c − a)a²]x + [(a − b)a²b + (b − c)b²c + (c − a)ac²]}`

이것은 흥미롭거나 실용적이기에는 너무 복잡해지고 있습니다.

방정식 (5)와 유사하게 세 항 중 하나만 남는 또 다른 방법은 다음과 같습니다.

`f(x) = ((-(x = c)) & a) + ((-(x = a)) & b) + ((-(x = b)) & c).`

이것은 기계가 *equal* 판별 연산(predicate)을 가지고 있다면, 상수 로드를 제외하고 11개의 명령어가 필요합니다. 두 덧셈 연산은 두 개의 0 값과 하나의 0이 아닌 값을 결합하므로, *or* 또는 *exclusive or* 연산으로 대체될 수 있습니다.

이 공식은 `a – c`와 `b – c`를 미리 계산한 다음 [GLS1]을 사용하여 단순화할 수 있습니다:

`f(x) = ((-(x = c)) & (a – c)) + ((-(x = a)) & (b – c)) + c, 또는`
`f(x) = ((-(x = c)) & (a ⊕ c)) ⊕ ((-(x = a)) & (b ⊕ c)) ⊕ c.`

---

**[MODEL]** (2025. 11. 2. 오후 9:38:40)

**Page 57 Translation:**

이러한 각 연산은 8개의 명령어를 사용하지만, 대부분의 기계에서는 아래에 보이는 간단한 C 코드보다 성능이 좋지 않을 것입니다. 이 C 코드는 작은 a, b, c에 대해 4개에서 6개의 명령어로 실행됩니다.

[코드 이미지를 보려면 여기를 클릭하세요](https://i.imgur.com/placeholder.png)

```c
if (x == a) x = b;
else if (x == b) x = c;
else x = a;
```

이 문제를 더 탐구해 보면, 비교 술어(comparison predicate) 명령어가 없는 기계에서 세 값 사이를 순환하는 기발한 분기 없는(branch-free) 방법이 있습니다 [GLS1]. 이 방법은 대부분의 기계에서 8개의 명령어로 실행됩니다.

a, b, c는 서로 다른 값이므로, a, b, c의 비트가 모두 같지는 않은 두 개의 비트 위치 n₁과 n₂가 존재합니다. 그리고 "유일하게 다른 값(odd one out)"(해당 위치의 비트가 다른 두 값의 비트와 다른 값)은 위치 n₁과 n₂에서 서로 다릅니다. 이는 아래에 이진수로 표시된 값 21, 31, 20의 예시로 설명되어 있습니다.

***

### 이진수 표현 예시

아래는 값 c (20), a (31), b (21)를 이진수로 나타낸 것입니다. 비트 위치 n₁과 n₂가 표시되어 있습니다.

```
1 0 1 0 1   c
1 1 1 1 1   a
1 0 1 0 0   b
  n₁    n₂
```

***

일반성을 잃지 않고, 위에서 보인 것처럼 위치 n₁에서는 a가, 위치 n₂에서는 b가 '유일하게 다른 값'이 되도록 a, b, c의 이름을 다시 지정합니다. 그러면 위치 n₁의 비트 값에 대한 두 가지 가능성이 있습니다. 즉, (aₙ₁, bₙ₁, cₙ₁) = (0, 1, 1) 또는 (1, 0, 0)입니다. 마찬가지로, 위치 n₂의 비트 값에 대해서도 두 가지 가능성이 있습니다. 즉, (aₙ₂, bₙ₂, cₙ₂) = (0, 1, 0) 또는 (1, 0, 1)입니다. 이로 인해 총 네 가지 경우가 만들어지며, 각 경우에 대한 공식은 아래와 같습니다.

경우 1. (aₙ₁, bₙ₁, cₙ₁) = (0, 1, 1), (aₙ₂, bₙ₂, cₙ₂) = (0, 1, 0):
*f(x) = xₙ₁ * (a − b) + xₙ₂ * (c − a) + b*

경우 2. (aₙ₁, bₙ₁, cₙ₁) = (0, 1, 1), (aₙ₂, bₙ₂, cₙ₂) = (1, 0, 1):
*f(x) = xₙ₁ * (a − b) + xₙ₂ * (a − c) + (b + c − a)*

경우 3. (aₙ₁, bₙ₁, cₙ₁) = (1, 0, 0), (aₙ₂, bₙ₂, cₙ₂) = (0, 1, 0):
*f(x) = xₙ₁ * (b − a) + xₙ₂ * (c − a) + a*

경우 4. (aₙ₁, bₙ₁, cₙ₁) = (1, 0, 0), (aₙ₂, bₙ₂, cₙ₂) = (1, 0, 1):
*f(x) = xₙ₁ * (b − a) + xₙ₂ * (a − c) + c*

이 공식들에서 각 곱셈의 왼쪽 피연산자는 단일 비트입니다. 0 또는 1과의 곱셈은 0 또는 모든 비트가 1인 값과의 *and* 연산으로 변환될 수 있습니다. 따라서 이 공식들은 다음과 같이 다시 작성될 수 있습니다.

---

**[MODEL]** (2025. 11. 2. 오후 9:39:12)

**Page 58 Translation:**

첫 번째 공식에 대해 아래에 설명되어 있습니다.

```
f(x) = ((x << (31-n₁)) >> 31)&(a - b) + ((x << (31-n₂)) >> 31)&(c-a) + b
```

x를 제외한 모든 변수가 상수이므로, 이것은 기본 RISC에서 8개의 명령어로 계산될 수 있습니다. 여기서도 덧셈과 뺄셈은 배타적 논리합(exclusive or)으로 대체될 수 있습니다.

이 아이디어는 4개 이상의 상수를 순환하는 데 확장될 수 있습니다. 아이디어의 핵심은 비트들이 상수를 고유하게 식별하는 비트 위치 n₁, n₂, ...를 찾는 것입니다. 4개의 상수에 대해서는 3개의 비트 위치면 항상 충분합니다. 그러면 (4개의 상수에 대해) s, t, u, v에 대한 다음 방정식을 풉니다 (즉, f(x)가 a, b, c, 또는 d이고 계수 xnᵢ가 0 또는 1인 4개의 선형 방정식 시스템을 풉니다):

```
f(x) = xn₁s + xn₂t + xn₃u + v
```

만약 4개의 상수가 단 두 개의 비트 위치로만 고유하게 식별된다면, 풀어야 할 방정식은 다음과 같습니다.

```
f(x) = xn₁s + xn₂t + xn₁xn₂u + v.
```

### 2-22 불 분해 공식

이 절에서는 3, 4, 또는 5개 변수의 임의의 불 함수를 구현하는 데 충분한 이진 불 연산, 즉 명령어의 최소 개수를 살펴봅니다. “불 함수”란 불 인수에 대해 불 값을 갖는 함수를 의미합니다.

불 대수에 대한 우리의 표기법은 or에 대해 “+”를, and에 대해 병치를, exclusive or에 대해 ⊕를, 그리고 not에 대해 윗줄 또는 접두사 ¬를 사용합니다. 이 연산자들은 단일 비트 피연산자나 컴퓨터 워드에 “비트 단위(bitwise)”로 적용될 수 있습니다. 우리의 주요 결과는 다음 정리입니다:

**정리.** 만약 f(x, y, z)가 3개 변수의 불 함수라면, 이는 g(x, y) ⊕ zh(x, y) 형태로 분해될 수 있으며, 여기서 g와 h는 2개 변수의 불 함수입니다.⁶

**증명** [Ditlow]. f(x, y, z)는 최소항의 합으로 표현될 수 있으며, 그 항들로부터 z̄와 z를 인수분해하면 다음과 같습니다.

```
f(x, y, z) = z̄f₀(x, y) + zf₁(x, y).
```

“+”의 피연산자들이 둘 다 1이 될 수 없으므로, or는 배타적 논리합으로 대체될 수 있으며, 결과는 다음과 같습니다.

```
f(x, y, z) = z̄f₀(x, y) ⊕ zf₁(x, y)
           = (1 ⊕ z)f₀(x, y) ⊕ zf₁(x, y)
           = f₀(x, y) ⊕ zf₀(x, y) ⊕ zf₁(x, y)
           = f₀(x, y) ⊕ z(f₀(x, y) ⊕ f₁(x, y)),
```

여기서 우리는 항등식 (a ⊕ b) c = ac ⊕ bc를 두 번 사용했습니다.

이것은 g(x, y) = f₀(x, y)이고 h(x, y) = f₀(x, y) ⊕ f₁(x, y)인 필수 형태입니다. 참고로, f₀(x, y)는 z = 0일 때의 f(x, y, z)이고, f₁(x, y)는 z = 1일 때의 f(x, y, z)입니다.

**따름정리.** 만약 컴퓨터의 명령어 집합이 2개 변수의 16개 불 함수 각각에 대한 명령어를 포함한다면, 3개 변수의 임의의 불 함수는 4개 (또는 그 이하)의 명령어로 구현될 수 있습니다.

---

**[MODEL]** (2025. 11. 2. 오후 9:39:49)

**Page 59 Translation:**

하나의 명령어는 g(x, y)를 구현하고, 다른 명령어는 h(x, y)를 구현하며, 이들은 and와 exclusive or(배타적 논리합)로 결합됩니다.

예를 들어, x, y, z 중 정확히 두 개가 1일 때 1이 되는 부울 함수를 생각해 봅시다:

```
f(x, y, z) = xy_z̅ + x_y̅z + _x̅yz.
```

더 진행하기 전에, 관심 있는 독자는 이 정리를 사용하지 않고 네 개의 명령어로 f를 구현해 볼 수 있습니다.

정리의 증명으로부터,

```
f(x, y, z) = f₀(x, y) ⊕ z(f₀(x, y) ⊕ f₁(x, y))
          = xy ⊕ z(xy ⊕ (x_y̅ + _x̅y))
          = xy ⊕ z(x + y),
```

이는 네 개의 명령어입니다.

분명히, 이 정리는 4개 이상의 변수를 갖는 함수로 확장될 수 있습니다. 즉, 모든 부울 함수 f(x₁, x₂, ..., xn)는 g(x₁, x₂, ..., xn-₁) ⊕ xn h(x₁, x₂, ..., xn-₁) 형태로 분해될 수 있습니다. 따라서, 4개 변수 함수는 다음과 같이 분해될 수 있습니다:

```
f(w, x, y, z) = g(w, x, y) ⊕ zh(w, x, y), 여기서
g(w, x, y) = g₁(w, x) ⊕ yh₁(w, x) 이고
h(w, x, y) = g₂(w, x) ⊕ yh₂(w, x).
```

이는 16개의 모든 이진 부울 함수에 대한 명령어를 가진 컴퓨터가 10개의 명령어로 4개 변수의 어떤 함수든 구현할 수 있음을 보여줍니다. 유사하게, 5개 변수의 어떤 함수든 22개의 명령어로 구현될 수 있습니다.

하지만, 훨씬 더 효율적으로 수행하는 것이 가능합니다. 4개 이상의 변수를 갖는 함수에 대해서는 정리가 제공하는 것과 같은 간단한 대입식은 아마도 없겠지만, 전산 완전 탐색이 수행되었습니다. 그 결과, 4개 변수의 어떤 부울 함수든 7개의 이진 부울 명령어로 구현될 수 있으며, 5개 변수의 어떤 함수든 12개의 그러한 명령어로 구현될 수 있다는 것이 밝혀졌습니다 [Knu4, 7.1.2].

5개 변수의 경우, 2²⁵ = 4,294,967,296개의 함수 중 1920개만이 12개의 명령어를 필요로 하며, 이 1920개의 함수들은 모두 본질적으로 동일한 함수입니다. 변형은 인수를 순열하거나, 일부 인수를 그 보수로 대체하거나, 함수의 값을 보수화하여 얻어집니다.

### 2-23 모든 16개 이진 부울 연산을 위한 명령어 구현

일부 컴퓨터의 명령어 집합에는 16개의 모든 이진 부울 연산이 포함됩니다. 이 명령어들 중 다수는 다른 명령어로도 그 기능을 수행할 수 있다는 점에서 불필요합니다. 예를 들어, 함수 f(x, y) = 0은 단순히 레지스터를 초기화하며, 대부분의 컴퓨터에는 이를 수행할 다양한 방법이 있습니다. 그럼에도 불구하고, 컴퓨터 설계자가 16개 모두를 구현하기로 선택할 수 있는 한 가지 이유는 이를 수행하기 위한 간단하고 매우 규칙적인 회로가 있기 때문입니다.

16개의 모든 이진 부울 함수를 보여주는 17페이지의 표 2-1을 참조하십시오. 이 함수들을 명령어로 구현하기 위해, 연산 부호(opcode) 비트 중 4개를 표에 표시된 함수 값과 동일하게 선택합니다. 이 연산 부호 비트들을 c₀, c₁, c₂, c₃로 표기하고, 표의 아래에서 위로 읽어 나갑니다.

---

**[MODEL]** (2025. 11. 2. 오후 9:40:27)

**Page 60 Translation:**

그리고 입력 레지스터 x와 y에 의해, 16개의 모든 이진 불리언 연산을 구현하기 위한 회로는 다음 논리식으로 설명됩니다.
c₀xy + c₁xȳ + c₂x̄y + c₃x̄ȳ.

예를 들어, c₀ = c₁ = c₂ = c₃ = 0이면, 명령어는 제로 함수 f(x, y) = 0을 계산합니다. c₀ = 1이고 다른 opcode 비트가 0이면, 이것은 and 명령어입니다. c₀ = c₃ = 0이고 c₁ = c₂ = 1이면, 이것은 exclusive or(배타적 논리합)이며, 이런 식으로 계속됩니다.

이것은 n개의 4:1 MUX로 구현될 수 있으며, 여기서 n은 기계의 워드 크기입니다. x와 y의 데이터 비트는 선택 라인이고, 네 개의 opcode 비트는 각 MUX의 데이터 입력입니다. MUX는 오늘날 기술에서 표준적인 구성 요소이며, 보통 매우 빠른 회로입니다. 아래에 그림으로 나타나 있습니다.

***

### 4:1 MUX 회로도

아래는 4:1 멀티플렉서(MUX)의 블록 다이어그램입니다.

*   **입력:**
    *   데이터 입력: c₀, c₁, c₂, c₃
    *   선택 라인: x, y
*   **구성 요소:** 중앙에 "4:1 MUX"라고 표시된 상자가 있습니다.
*   **출력:** 오른쪽으로 향하는 단일 출력 라인이 있습니다.

이 회로는 선택 라인 x와 y의 값에 따라 4개의 데이터 입력(c₀, c₁, c₂, c₃) 중 하나를 선택하여 출력으로 내보냅니다.

***

이 회로의 기능은 x와 y가 각각 00, 01, 10, 또는 11인지에 따라 c₀, c₁, c₂, 또는 c₃ 중 하나를 출력으로 선택하는 것입니다. 이것은 4위치 회전 스위치와 같습니다.

이 방식은 우아하지만, 16개의 opcode 포인트를 사용하므로 다소 비효율적입니다. 덜 규칙적인 논리를 희생하는 대신, 단 8개의 opcode 포인트만을 사용하여 16개의 모든 불리언 연산을 구현하는 여러 방법이 있습니다. 그러한 방식 중 하나가 표 2-3에 설명되어 있습니다.

### 표 2-3. 8개의 충분한 불리언 명령어

| 함수 값 | 수식 | 명령어 니모닉 (이름) |
| :--- | :--- | :--- |
| 0001 | xy | and |
| 0010 | xȳ | andc (보수와 and) |
| 0110 | x ⊕ y | xor (배타적 논리합) |
| 0111 | x + y | or |
| 1110 | x̅y̅ | nand (부정 and) |
| 1101 | x̄y, 또는 x̄ + y | cor (보수 and or) |
| 1001 | x̅ ⊕̅ ̅y̅, 또는 x ≡ y | eqv (동치) |
| 1000 | x̅ ̅+̅ ̅y̅ | nor (부정 or) |

표에 보이지 않는 나머지 8개의 연산은, 입력을 서로 바꾸거나 명령어의 두 레지스터 필드가 동일한 레지스터를 참조하게 함으로써, 표에 있는 8개의 명령어로 수행할 수 있습니다. 연습문제 13을 참조하십시오.

IBM의 POWER 아키텍처는 이 방식을 사용하며, POWER가 or with를 가진다는 사소한 차이점이 있습니다.

---

**[MODEL]** (2025. 11. 2. 오후 9:40:52)

**Page 61 Translation:**

`보수와 논리합(or)`이 아닌 `보수` 연산. `표 2-3`에 나타난 방식은 마지막 네 개의 명령어를 각각 처음 네 개의 명령어의 결과를 보수화하여 구현할 수 있게 해준다.

### 역사적 참고 사항

조지 불(George Boole)의 *사고의 법칙에 대한 연구(An Investigation of the Laws of Thought)* (1854)²에서 설명된 논리 대수는 오늘날 우리가 "부울 대수"라고 알고 있는 것과는 다소 차이가 있다. 불은 정수 1과 0을 사용하여 각각 참과 거짓을 나타냈으며, 일반적인 수치 대수 방법으로 이를 조작하여 "그리고(and)", "또는(or)", "제외하고(except)"를 포함하는 자연어 문장을 형식화하는 방법을 보여주었다. 그는 또한 교집합, 서로소 집합의 합집합, 여집합 연산을 포함하는 집합론의 문장을 형식화하기 위해 일반 대수를 사용했다. 또한 변수가 0에서 1 사이의 실수 값을 갖는 확률론의 문장도 형식화했다. 이 저서는 종종 철학, 종교, 법률의 문제를 다룬다.

불이 논리에 관한 위대한 사상가로 여겨지는 이유는 그가 논리를 형식화하여, 복잡한 문장들을 일반 대수의 익숙한 방법으로 기계적이고 흠 없이 조작할 수 있게 했기 때문이다.

역사를 건너뛰어 보면, 16개의 모든 부울 연산을 포함하는 몇몇 프로그래밍 언어들이 있다. IBM의 PL/I(1966년경)는 BOOL이라는 내장 함수를 포함한다. BOOL(x, y, z)에서 z는 길이가 4인 비트 문자열(필요시 변환됨)이며, x와 y는 길이가 같은 비트 문자열(필요시 변환됨)이다. 인자 z는 x와 y에 수행될 부울 연산을 지정한다. 이진수 0000은 0 함수이고, 0001은 xy, 0010은 xȳ 등이다.

또 다른 예로 Wang System 2200B 컴퓨터(1974년경)용 Basic이 있는데, 이는 비트 문자열이나 정수가 아닌 문자열에 대해 작동하는 BOOL 버전을 제공한다 [Neum].

또 다른 언어로는 MIT PDP-6 Lisp이 있으며, 이는 나중에 MacLisp으로 불렸다 [GLS1].

### 연습 문제

1.  David de Kloet는 x ≠ 0일 때 snoob 함수에 대한 다음 코드를 제안한다. 여기서 y에 대한 최종 할당이 결과가 된다:

    ```
    y ← x + (x & -x)
    x ← x & ¬y
    while((x & 1) = 0) x ← x » 1
    x ← x » 1
    y ← y | x
    ```

    이것은 오른쪽 시프트가 나눗셈 명령어가 아닌 while 루프로 수행된다는 점을 제외하면 본질적으로 Gosper의 코드(15페이지)와 동일하다. 나눗셈은 일반적으로 시간 비용이 높기 때문에, while 루프가 너무 많이 실행되지 않는다면 이 코드는 Gosper의 코드와 경쟁력이 있을 수 있다. 비트 문자열 x와 y의 길이를 n, 문자열의 1-비트 개수를 k라고 하고, 코드가 정확히 k개의 1-비트를 갖는 모든 x 값에 대해 실행된다고 가정하자. 그렇다면 함수가 호출될 때마다 while 루프의 본문은 평균적으로 몇 번 실행될 것인가?

2.  본문에서는 가변량만큼 왼쪽 시프트하는 것이 오른쪽에서 왼쪽으로 계산 가능하지 않다고 언급한다. 함수 x << (x & 1) [Knu8]을 생각해보자. 이것은 가변량만큼 왼쪽 시프트하는 것이지만, ... (이하 생략)

---

**[SYSTEM]** (2025. 11. 2. 오후 9:51:49)

Translation finished.

---
